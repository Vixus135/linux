# Практическая работа 16
Данная папка содержит реализацию одного упражнения из 16-й практической работы  
по теме «Многопоточное программирование»

## Структура проекта
```
├── main.c # Основная логика запуска потоков
├── funcs.c # Функции для работы с очередью сообщений
├── Makefile # Файл для сборки проекта
├── proizPotrib # Исполняемый файл
└── README.md # Описание работы
```
## Задание: Производитель–потребитель
#### Задача: 
Реализовать очередь сообщений, которая используется для обмена данными между несколькими потоками 
Очередь должна поддерживать следующие функции:
- `mymsginit(queue *)` — инициализация очереди
- `mymsgput(queue *, char *msg)` — добавление сообщения
- `mymsgget(queue *, char *buf, size_t bufsize)` — извлечение сообщения
- `mymsgdrop(queue *)` — завершение работы очереди
- `mymsgdestroy(queue *)` — освобождение ресурсов

#### Ограничения:
- Максимум 10 сообщений в очереди
- Каждое сообщение — строка до 80 символов
- Если очередь полна — `put` блокируется
- Если очередь пуста — `get` блокируется
- После вызова `drop` все ожидающие потоки разблокируются, и все последующие `put/get` возвращают `0`

## Логика программы
В демонстрации запускаются:
- **2 потока‑производителя**, каждый генерирует по 5 сообщений.
- **2 потока‑потребителя**, каждый извлекает по 5 сообщений.

Каждое сообщение имеет формат:  
`"Producer X: message Y"` — где X — номер производителя, Y — порядковый номер сообщения.  
Это позволяет отследить, кто создал сообщение и в каком порядке оно было помещено в очередь.

Очередь реализована как **кольцевой буфер**:
- Внутри хранится фиксированный массив строк длиной `MAX_MSG` (10 сообщений).
- Индексы `head` и `tail` указывают на начало и конец очереди.
- При добавлении сообщения `tail` сдвигается вперёд, при извлечении — `head`.  
- Когда индексы достигают конца массива, они «обнуляются» и продолжают движение с начала — это и есть кольцевая структура.

Для синхронизации используются:
- семафоры:
  - `semEmpty` — показывает, сколько свободных мест осталось в очереди. Производитель ждёт, если свободных мест нет.
  - `semFull` — показывает, сколько сообщений находится в очереди. Потребитель ждёт, если очередь пуста.
- мьютекс — защищает критическую секцию, чтобы только один поток мог изменять очередь в данный момент. Это предотвращает одновременную запись или чтение, которые могли бы привести к повреждению данных

## Почему программа работает
1. Семафоры управляют доступом к ресурсам.  
   Производители не могут положить сообщение, если очередь переполнена, а потребители не могут извлечь сообщение,
   если очередь пуста. Это гарантирует корректный порядок работы
2. Мьютекс предотвращает гонки
   Даже если два производителя одновременно захотят записать сообщение, мьютекс гарантирует,
   что они будут делать это по очереди. Аналогично для потребителей при извлечении
3. Кольцевая структура экономит память
   Вместо динамического выделения памяти под каждое сообщение используется фиксированный массив.
   Индексы `head` и `tail` циклически перемещаются, что делает очередь простой и эффективной
4. Параллельность без конфликтов
   Производители и потребители работают одновременно, но благодаря семафорам и мьютексу они не мешают друг другу.
   Производители могут продолжать создавать сообщения, пока есть место, а потребители — извлекать их, пока они есть в очереди.
5. Гарантия целостности данных
   Каждое сообщение, помещённое в очередь, будет извлечено ровно один раз. Нет потерь, дублирования или повреждения строк
6. Демонстрация многопоточности
   В выводе видно, что сообщения создаются и обрабатываются разными потоками
## Компиляция и запуск

Для компиляции используйте команду:
```bash
make
```
Для запуска:
```bash
./proizPotrib
```
Программа завершает работу автоматически после обработки всех сообщений
